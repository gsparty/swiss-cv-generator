from __future__ import annotations
from typing import List, Optional
import os
import json
import uuid
import random
import datetime
from pydantic import ValidationError

from .models import SwissPersona, EducationEntry, ExperienceEntry
from .sampler import sample_canton, sample_age, compute_years_experience_from_age, load_canton_populations

CURRENT_YEAR = datetime.date.today().year

# small language mapping & name pools (dev-friendly; expand later)
LANG_BY_CANTON = {
    "VD": "fr", "GE": "fr", "NE": "fr", "FR": "fr",
    "TI": "it",
    "ZH": "de", "BE": "de", "LU": "de", "AG": "de", "SG": "de", "GR": "de",
}
NAMES = {
    "de": [("Max","Muster"), ("Anna","Meier"), ("Lukas","Schneider"), ("Sophie","Frey")],
    "fr": [("Mathieu","Dupont"), ("Camille","Martin"), ("Julie","Bernard"), ("Lucas","Morel")],
    "it": [("Marco","Rossi"), ("Giulia","Bianchi"), ("Luca","Ferrari"), ("Elisa","Conti")],
    "en": [("Alex","Smith"), ("Sam","Jones")]
}

def _choose_name_for_lang(lang: str, rnd: random.Random):
    pool = NAMES.get(lang, NAMES["de"])
    return rnd.choice(pool)

def _format_phone(rnd: random.Random) -> str:
    prefix = rnd.choice(["76","77","78","79"])
    rest = "".join(str(rnd.randint(0,9)) for _ in range(7))
    return f"+41{prefix}{rest}"

def _format_email(first: str, last: str, rnd: random.Random) -> str:
    domain = rnd.choice(["example.ch","gmail.com","bluewin.ch","gmx.ch"])
    local = f"{first}.{last}".lower().replace(" ", "")
    return f"{local}@{domain}"

def _format_address(rnd: random.Random, canton: str) -> str:
    """Return a simple synthetic Swiss-like address string."""
    streets = [
        "Bahnhofstrasse", "Hauptstrasse", "Industriestrasse", "Seestrasse",
        "Kirchgasse", "Rathausgasse", "Schulstrasse", "Gartenweg"
    ]
    street = rnd.choice(streets)
    number = rnd.randint(1, 199)
    postal = rnd.randint(8000, 9999)
    city = canton  # simple; you can map canton->city later
    return f"{street} {number}, {postal} {city}"
def _make_experience_history(years_experience: int, current_title: str = "Engineer", canton: Optional[str] = None):
    """
    Create a single experience entry.
    For schema compatibility we ensure end_year is an integer (CURRENT_YEAR).
    (This is a pragmatic choice for synthetic current/most-recent jobs.)
    """
    start_year = CURRENT_YEAR - years_experience if years_experience > 0 else CURRENT_YEAR
    # pragmatic: set end_year to CURRENT_YEAR so JSON Schema (integer) is satisfied
    end_year = CURRENT_YEAR
    senior = SwissPersona.compute_seniority(years_experience)
    exp = ExperienceEntry(
        title=current_title,
        company="ACME AG",
        canton=canton,
        start_year=start_year,
        end_year=end_year,
        description="Worked on projects and delivered value.",
        seniority=senior
    )
    return [exp]

def generate_persona(
    seed: Optional[int] = None,
    canton: Optional[str] = None,
    industry: Optional[str] = None,
) -> SwissPersona:
    rnd = random.Random(seed)
    chosen_canton = canton or sample_canton(seed=rnd.randint(0,2**31-1))
    lang = LANG_BY_CANTON.get(chosen_canton, "de")
    first, last = _choose_name_for_lang(lang, rnd)
    age = sample_age(seed=rnd.randint(0,2**31-1))
    years_experience = compute_years_experience_from_age(age, rng=rnd)

    persona = SwissPersona(
        id=str(uuid.uuid4()),
        first_name=first,
        last_name=last,
        gender=rnd.choice(["male","female","other"]),
        language=lang,
        canton=chosen_canton,
        age=age,
        years_experience=years_experience,
        industry=industry or rnd.choice(["technology","finance","healthcare","manufacturing"]),
        current_title=rnd.choice(["Software Engineer","Data Analyst","Project Manager","Consultant"]),
        email=_format_email(first, last, rnd),
        phone=_format_phone(rnd),
        address=_format_address(rnd, chosen_canton),
        skills=["communication","problem solving"],
        languages_spoken=[lang],
        education=[EducationEntry(institution="University", degree="BSc", field="Computer Science", start_year=age-22-3, end_year=age-22)],
        experience=_make_experience_history(years_experience, current_title=rnd.choice(["Software Engineer","Analyst","Manager"], canton=chosen_canton)),
        summary=f"{first} {last} is a {years_experience}-year experienced professional in {rnd.choice(['software','data','project management'])}."
    )
    return persona

def generate(
    count: int = 5,
    seed: Optional[int] = 42,
    out_dir: str = "out_personas",
    canton: Optional[str] = None,
    industry: Optional[str] = None,
    validate_schema: bool = False,
    schema_path: Optional[str] = None
) -> List[str]:
    """
    Generate `count` personas and write JSON files to out_dir.
    Returns list of output file paths.
    If validate_schema=True, will attempt JSON Schema validation if schema_path provided.
    """
    rnd = random.Random(seed)
    os.makedirs(out_dir, exist_ok=True)
    created = []
    schema = None
    if validate_schema and schema_path and os.path.exists(schema_path):
        with open(schema_path, "r", encoding="utf8") as f:
            schema = json.load(f)

    for i in range(count):
        p = generate_persona(seed=rnd.randint(0,2**31-1), canton=canton, industry=industry)
        out_path = os.path.join(out_dir, f"persona_{i+1}_{p.id[:8]}.json")
        # Optionally validate via pydantic (will raise) and JSON Schema if requested
        try:
            # pydantic instance already validated on creation; write JSON
            json_text = p.json(indent=2, ensure_ascii=False)
            if schema is not None:
                # lazy import to avoid requiring jsonschema when not requested
                import jsonschema
                jsonschema.validate(json.loads(json_text), schema)
            with open(out_path, "w", encoding="utf8") as fh:
                fh.write(json_text)
            created.append(out_path)
        except (ValidationError, Exception) as e:
            # if validation fails, surface but continue generating others
            print(f"Warning: persona {i+1} failed validation: {e}")
    return created








